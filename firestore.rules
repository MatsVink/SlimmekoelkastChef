/**
 * This ruleset enforces security for the application's data, balancing
 * anonymous recipe history and user-specific favorite recipes.
 *
 * Core Philosophy:
 * The security model allows any user (including anonymous ones) to contribute to a global,
 * append-only recipe history. Additionally, any authenticated user (including anonymous)
 * can manage their own private list of favorite recipes.
 *
 * Data Structure:
 * - `/recipe_history`: A top-level collection for all generated recipes. It is append-only.
 * - `/users/{userId}/favorites`: A subcollection under each user (identified by their unique
 *   auth UID) to store their personal favorite recipes. Access is restricted to the owner.
 *
 * Key Security Decisions:
 * - Append-Only History: Users can only `create` new documents in `/recipe_history`.
 *   Read, update, and delete are denied to protect the integrity and privacy of the log.
 * - Owner-Only Favorites: Users can only read and write to their own `/favorites`
 *   subcollection. The `isOwner()` function enforces this by matching the user's UID
 *   with the `userId` in the path.
 * - Anonymous Users are Authenticated: The rules treat anonymous users as "signed in,"
 *   granting them the same capabilities as fully registered users for writing to history
 *   and managing their own favorites.
 *
 * Denormalization for Authorization:
 * The `userId` in the `/users/{userId}` path is the key piece of "denormalized" data
 * that enables authorization checks for the `favorites` subcollection.
 *
 * Structural Segregation:
 * The data is segregated into a public-write collection (`recipe_history`) and
 * private user-specific collections (`users/{userId}`), each with distinct security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions

    /**
     * Checks if the user is authenticated, including anonymous users.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of the document.
     * @param userId The UID of the user to check against.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description
     *   Rules for the `recipe_history` collection, which acts as an append-only log.
     *   Any signed-in user (including anonymous users) can create a new history
     *   entry, but no one can read, update, or delete any entries.
     */
    match /recipe_history/{recipeHistoryId} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description
     *   Rules for user-specific data. This path itself doesn't hold data but
     *   acts as a container for user subcollections.
     */
    match /users/{userId} {
      // Users can't directly read or write their main user document through the client.
      allow read, write: if false;

      /**
       * @description
       *   Rules for a user's 'favorites' subcollection.
       *   Only the owner of the user document can read, write, or delete
       *   their own favorite recipes. This applies to anonymous users as well.
       * @path
       *   /users/{userId}/favorites/{favoriteId}
       * @allow
       *   (read, write) The authenticated user's UID matches the {userId} in the path.
       */
      match /favorites/{favoriteId} {
        allow read, write: if isOwner(userId);
      }
    }
  }
}
